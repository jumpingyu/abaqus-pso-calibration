function [combinedError, errRatios, varargout] = ...
                 getABQerrorCombined(newparams, tests, testnums, errortype)
% This is the Objective Function for applying optimization techniques
%
% newparams = vector of material hardening parameters
% tests     = specifically designed .mat struct file containing test data
%             (see documentation)
% testnums  = Optional subset of tests on which to run analysis (vector of 
%             indices), or string 'all'. Default = 'all'
% errortype = selector for internal error designation (see documentation or
%             calcResidualError.m). Default = 4

persistent RUNCHECK FHANDLE

%
% Recover Parameters from newparams ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%

% check if newparams comes from normalized PSO, or is actual AF params
% (this is a disgusting hack)
if mod(length(newparams),2) == 0
    % length newparams is even, meaning it is a normalized PSO param vector

    % newparams(1) = Fy
    % newparams(2) = total hardening
    % newparams(3) = C0 (linear kinematic term)
    % newparams(4) = b (isotropic rate term)
    % newparams(5,7,...) = gamman (nth kinematic rate)
    % newparams(6,8,...) = fraction saturated hardening per ksi backstress
    
    Fy = newparams(1);
    C0 = newparams(3);
    b  = newparams(4);
    Cn = [];
    gamman = [];
    
    totalksi=0;
    for n = 1:( (length(newparams) - 4)/2 )
        % extract params, keeping track of total ksi for Qinf
        gamman(n) = newparams(2*n+3); %#ok<*AGROW>
        Cn(n) = newparams(2) * newparams(2*n+4) * gamman(n);
        totalksi = totalksi + newparams(2) * newparams(2*n+4);
        
    end
    % set Qinf
    Qinf = newparams(2) - totalksi;
    
    % define AF params
    params = [Fy Qinf b C0 0 reshape([Cn;gamman],length(Cn)*2,1)'];

else
    % length newparams is odd, meaning it is already set to be AF params
    params = newparams;
    
    % in almost all cases, this is not what the user wants.
    warning(['Input is inconsistent with normalized PSO parameters... ',...
             'instead, assuming they are pre-defined AF parameters.']);
end

%
% rudimentary check on parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%

% get all field names of the .mat struct
testnames = fieldnames(tests);

% check the requested inputs...
if (nargin < 3) || strcmpi(testnums,'all') || isempty(testnums)
    % run all tests if not otherwise specified
    testnums = 1:length(testnames);
end

if (nargin < 4) || isempty(errortype)
    % default to error type 4 if not otherwise specified
    errortype = 4;
end

% obtain the relevant test names
testnames = testnames(testnums);

% if this is the first time the function has been called, check some of the
% user inputs to verify that they will work, before we begin time-consuming
% analysis.
if isempty(RUNCHECK)
    checkRequiredUserInputs(tests, testnames)
    RUNCHECK = false;
end

% preallocate fracture mechanics output (necessary if any params < 0)
nanvec    = NaN * ones(1,length(testnums));
PEEQfinal = nanvec;
Tfinal    = nanvec;
Xfinal    = nanvec;
SMCSfinal = nanvec;
CVGMfinal = nanvec;

if any( params < 0 )
    % if any parameters are less than zero, return nothing
    combinedError = 1;
    errRatios = 1;
    varargout{1} = PEEQfinal;
    varargout{2} = Tfinal;
    varargout{3} = Xfinal;
    varargout{4} = SMCSfinal;
    varargout{5} = CVGMfinal;

    disp('Out of bounds')
    return;
end

%
% calculate the combined error ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%

% display information for user
fprintf('Writing INP Histories...');

% using a template input file, insert our own *Static and *Amplitude
% keyword settings, based on test displacement peaks (hist)
for i = 1:length(testnames)
    % addHistINPfile(template, target, testdata)
    writeHistINPfile( tests.(testnames{i}).template, [testnames{i} '.inp'], ...
                    tests.(testnames{i}) );
end
fprintf(' Done!\n');

% copy the input file generated by addHistINPfile
% write constituitive params to this copy
fprintf('Writing INP Parameters...');
for i = 1:length(testnames)
    % writeParamsINPfile(basefile, newfile, params)
    writeParamsINPfile( testnames{i}, [testnames{i} '-dum'], params );
end
fprintf(' Done!\n');

% run all requested jobs; load balance so only 5 are running simultaneously
msghandle = msgbox('Running Abaqus Jobs...');
runAbaqusJobs(strcat(testnames, '-dum'), 5);

% clean up msgbox
if ishandle(msghandle)
    close(msghandle);
end

% preallocate the error and error ratio
err       = ones(size(testnames));
errRatios = err;

% obtain the error for each test/simulation
fprintf('Extracting Errors from ODBs...');
for i = 1:length(testnames)

    % set job's .ODB name (also the name of the .INP file)
    fileID = [testnames{i} '-dum'];
    
    % set the name of the assembly-level reaction node set
    rxNodeSet = tests.(testnames{i}).rxNodeSet;
    
    % set the "real" test data
    if tests.(testnames{i}).symmetric
        % if the simulation is symmetric, divide displ by 2
        realdata = [tests.(testnames{i}).displ/2, tests.(testnames{i}).force];
    else
        % otherwise, use full displ
        realdata = [tests.(testnames{i}).displ, tests.(testnames{i}).force];
    end
    
    % calculate the residual error for this simulation
    [err(i), errRatios(i), forceDispl{i}] = ...
                 calcResidualError(fileID, realdata, errortype, rxNodeSet);
end
fprintf(' Done!\n');

% sum up the error for the PSO algorithm
combinedError = sum(errRatios);

%
% save parameter and error data to a .mat struct ~~~~~~~~~~~~~~~~~~~~~~~~~~
%
alldata = struct('params',params, 'newparams',newparams, ...
                 'combinedError',combinedError);

if exist('historyData.mat','file') == 2
    % if the .mat struct already exists... we want to append.
    load historyData historyData
    historyData{length(historyData)+1} = alldata;
else
    % otherwise, save as a new set of data.
    historyData{1} = alldata;
end

% save into .mat struct file
save historyData historyData

%
% if requested, perform fracture mechanics calcs ~~~~~~~~~~~~~~~~~~~~~~~~~~
%

fprintf('Extracting Fracture Mechanics Data, if requested...');
for i = 1:length(testnames)
    if ~isfield(tests.(testnames{i}),'getIntPtData')
        % if no field is defined, assume calcs not wanted
        continue
    end
    
    % otherwise, check if they are requested...
    if tests.(testnames{i}).getIntPtData
        IntPtNodeSet = tests.(testnames{i}).IntPtNodeSet;
        [~, PEEQ, Mises, Pressure, Inv3] = ...
                                   fetchOdbIntPtData(fileID, IntPtNodeSet);
    

        % triaxiality, PEEQ, and ... some other thing?
        % not sure what the cube of inv3/mises is. (something Chris wrote)
        PEEQfinal(i) =   PEEQ(end);
        Tfinal(i)    = - Pressure(end) / Mises(end); % triaxiality
        Xfinal(i)    =   ( Inv3(end) / Mises(end) )^3;
        
        % triaxiality history
        T = - Pressure(:) ./ Mises(:);
        T(isnan(T)) = 0; % if Mises is 0, triax is NaN
        
        % calculate SMCS and CVGM. See Kanvinde and Deierlein (2007)
        SMCSfinal(i) = PEEQfinal(i) / exp(-1.5*Tfinal(i));
        CVGMfinal(i) = sum( exp(1.5*abs(T)).*sign(T).*[0; diff(PEEQ)] ) ... 
                       / exp(-.47*sum([0; diff(PEEQ)].*(T<0)));
    end
end
fprintf(' Done!\n');

% assign output to varargout
varargout{1} = PEEQfinal;
varargout{2} = Tfinal;
varargout{3} = Xfinal;
varargout{4} = SMCSfinal;
varargout{5} = CVGMfinal;


%
% plot comparison of force-displacement ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%

if isempty(FHANDLE)
    FHANDLE = figure;
else
    % need try-catch statement for an extremely rare bug where sometimes
    % FHANDLE is defined but invalid
    try
        figure(FHANDLE);
    catch
        FHANDLE = figure;
    end
end

splotwidth  = ceil(sqrt(length(testnames)));
splotheight = ceil(length(testnames)/splotwidth);

for i = 1:length(testnames)
    subplot(splotwidth, splotheight, i);
    
    % plot simulation data
    if tests.(testnames{i}).symmetric
        plot( forceDispl{i}(:,3)*2, forceDispl{i}(:,2),'g' )
    else
        plot( forceDispl{i}(:,3), forceDispl{i}(:,2),'g' )
    end
    hold on
    
    % plot real test data
    plot(tests.(testnames{i}).displ, tests.(testnames{i}).force);
    
    % give it a meaningful title
    title_ = sprintf(' %s\n errRatio = %s', ...
                     testnames{i}, num2str(errRatios(i)));
    title(title_);
end

end